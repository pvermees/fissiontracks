# fname: the name of a .csv file containing the length measurements
# confined = FALSE if fname contains semi-tracks, = TRUE if it contains confined tracks
# cutoff: the shortest semi track which we can reliably measure with the microscope
# header: does the .csv file contain a header?
# skip: how many lines does the header contain
read.data <- function(fname,confined=FALSE,cutoff=4,header=TRUE,skip=2){
    dat <- read.csv(file=fname,header=header,skip=skip)
    out <- list()
    out$confined <- confined
    out$l <- dat$True.Length
    out$a <- dat$Angle.to.C
    if (!confined) {
        islong <- out$l>cutoff
        out$l <- out$l[islong]
        out$a <- out$a[islong]
    }
    out
}

# equation 7.53
getN <- function(mu){
    return (-5.18 + 1.42*mu - sqrt(11.48 - 2.13*mu + 0.1*mu^2))
}

# equation 7.53
getE <- function(mu){
    return(2*(mu-getN(mu)))
}

# middle of page 140
getMs <- function(mu){
    return(getN(mu)+4*getE(mu)/(3*pi))
}

# equation 7.51
# get the probability density of length l and angle(s) phi
# M, S, l, theta and f are scalars
fcLPhi <- function(l,phi,M,S){
    N <- getN(M)
    E <- getE(M)
    f <- dnorm(l,mean=N+E*cos(phi),sd=S)
    return(f)
}

# equation 2.4
# get the probability density at confined FT length l integrating over phi
# l is a scalar, while P, M and S are vectors of equal length
getfcL <- function(l,P,M,S){
    f <- 0
    for (i in 1:length(P)){
        integrand <- function(phi) {sin(phi)*fcLPhi(l,phi,M[i],S[i])}
        f <- f + P[i]*integrate(integrand,lower=0,upper=pi/2)$value
    }
    return(f)
}

# first equation of page 126
# x, M and S are scalars, phi is a vector
FcLPhi <- function(x,phi,M,S){
    N <- getN(M)
    E <- getE(M)
    f <- pnorm(x,mean=N+E*cos(phi),sd=S)
    return(f)
}

# equation 7.32
# probability density at semi-track length tt
getfsL <- function(tt,P,M,S){
    f <- 0 # initialise
    for (i in 1:length(P)){
        integrand <- function(phi) {(1-FcLPhi(tt,phi,M[i],S[i]))*sin(phi)^2}
        Ms <- getMs(M[i])
        f <- f + P[i]*4*integrate(integrand,lower=0,upper=pi/2)$value/(pi*Ms)
    }
    f
}

# P = vector with the proportions of the length peaks
# M = vector with the means of the length peaks
# S = vector with the standard deviations of the length peaks
# P, M and S must have the same lengths
forward <- function(P,M,S) {
    # calculate the confined and semi-track length distributions
    l <- seq(from=0,to=20,by=0.01) # confined fission track lengths to evaluate
    fc <- l
    fs <- l
    for (i in 1:length(l)){       # loop through all the lengths
        fc[i] <- getfcL(l[i],P,M,S)  # calculate the pdf of the confined track lengths
        fs[i] <- getfsL(l[i],P,M,S)  # calculate the pdf of the semi-track lengths
    }
    out = list(l=l,fs=fs,fc=fc,P=P,M=M,S=S)
    return(out)
}

# maximum likelihood misfit function for confined tracks
cmisfit <- function(P,M,S,l){
    fcL <- unlist(lapply(l,getfcL,P=P,M=M,S=S))
    return(sum(log(fcL)))
}

# maximum likelihood misfit function for semi-tracks
smisfit <- function(P,M,S,l){
    fsL <- unlist(lapply(l,getfsL,P=P,M=M,S=S))
    cutoff <- min(l)
    fsL.of.uncounted <- getfsL(cutoff,P=P,M=M,S=S)
    dl <- 2
    num.of.short.tracks <- sum(l>=cutoff & l<(cutoff+dl))
    num.uncounted <- num.of.short.tracks*cutoff/dl
    corr.term <- num.uncounted*log(fsL.of.uncounted)
    return(sum(log(fsL))+corr.term)
}

modify2 <- function(m,Lm=4,LM=16){
    out <- m
    ss <- runif(1) # stepsize
    ncomp <- length(m$M)
    logPP1 <- log(out$P[-1]/out$P[1])
    logPP1p <- logPP1 + ss*(runif(ncomp-1)-0.5)
    out$P <- c(1,exp(logPP1p))/(1+sum(exp(logPP1p)))
    dM <- diff(c(Lm,m$M,LM))
    X <- log(dM[-1]/dM[1])
    Xp <- X + ss*(runif(ncomp)-0.5)
    dMp <- c(1,exp(Xp))/(1+sum(exp(Xp)))
    Mp <- Lm+cumsum(dMp)*(LM-Lm)
    out$M <- Mp[1:ncomp]
    out$S <- out$M*exp(log(m$S/m$M)+ss*(runif(1)-0.5))
    out
}

modify <- function(m,Lm=4,LM=16){
    out <- m
    ss <- runif(1) # stepsize
    ncomp <- length(m$M)
    M <- m$M
    P <- m$P
    S <- m$S
    r <- 2*(runif(ncomp)-0.5)
    MU <- c(M,LM)[-1]
    ML <- c(Lm,M)[1:ncomp]
    dM <- ((r>0)*(MU-M) + (r<0)*(M-ML))*ss*r
    r <- 2*(runif(ncomp)-0.5)
    dP <- ((r>0)*(1-P) + (r<0)*P)*ss*r
    r <- 2*(runif(ncomp)-0.5)
    dSM <- ((r>0)*(0.5-S/M) + (r<0)*(S/M))*ss*r
    out$M <- M+dM
    out$P <- (P+dP)/sum(P+dP)
    out$S <- (S/M + dSM)*out$M
    out
}

# dat: fission track length data generated by the read.data function
# ncomp: the number of Normal components to fit
invert <- function(dat,ncomp=3,nsolutions=1000){
    ll <- dat$l
    P <- rep(1/ncomp,ncomp)
    Lm <- 5
    LM <- 16
    M <- seq(from=Lm+(LM-Lm)/(ncomp+1),
             to=Lm+(LM-Lm)*ncomp/(ncomp+1),
             length.out=ncomp)
    S <- M/10
    m <- list(P=P,M=M,S=S,LL=-Inf)
    m.last <- m
    out <- NULL
    for (i in 1:10000){
        if (dat$confined){
            LL <- cmisfit(m$P,m$M,m$S,ll)
        } else {
            LL <- smisfit(m$P,m$M,m$S,ll)
        }
        if ((LL>m.last$LL) | (exp(LL-m.last$LL)>runif(1))) {
            m$LL <- LL # update log-likelihood
            m.last <- m # accept new model
            newrow <- c(m$P,m$M,m$S,m$LL)
            out <- rbind(out,newrow,deparse.level=0)
            nm <- nrow(out) # number of accepted models
            print(nm)
            if (nm>(nsolutions-1)) break
        } else {
            m <- m.last # revert to previous model
        }
        m <- modify(m,Lm,LM) # create new model
    }
    colnames(out) <- c(paste0('P',1:ncomp),paste0('M',1:ncomp),paste0('S',1:ncomp),'LL')
    out
}

best <- function(fit){
    ncomp <- (ncol(fit)-1)/3
    out <- list()
    out$LL <- max(fit[,'LL'])
    i <- which(fit[,'LL']==out$LL)
    b <- fit[i,]
    out$P <- b[1:ncomp]
    out$M <- b[(ncomp+1):(2*ncomp)]
    out$S <- b[(2*ncomp+1):(3*ncomp)]
    out
}

# fit: an ensemble of models generated by the inverse() function
# dat: some data generated by the read.data function
plotResults <- function(fit,dat) {
    b <- best(fit)
    m <- forward(b$P,b$M,b$S)
    plotModel(m,dat)
    plot(1:nrow(fit),fit[,'LL'],type='l',xlab='iteration',ylab='LL')
}

plotModel <- function(m,d){
    h <- hist(d$l)
    par(pty='s',mfrow=c(2,2))
    clab <- expression(paste("confined track length [",mu,"m]"))
    slab <- expression(paste("semi-track length [",mu,"m]"))
    if (d$confined){ lab <- clab }
    else { lab <- slab }
    plot(d$l,d$a,type='p', xlab=lab, ylab='angle to C')
    plot(h,freq=FALSE,main='',ylim=range(h$density,m$fs),xlab=lab)
    if (d$confined){
        lines(m$l,m$fc)
        plot(m$l,m$fs,type='l',xlab=slab)
    } else {
        cutoff <- min(d$l)
        fsL.of.uncounted <- getfsL(cutoff,P=m$P,M=m$M,S=m$S)
        corr.factor <- 1/(1-cutoff*fsL.of.uncounted)
        lines(m$l,m$fs*corr.factor)
        plot(m$l,m$fc,type='l',xlab=clab,ylab='Density')
    }
}

# generates simulated confined fission tracks
# fit: the output of the inverse() function
# N: the number of confined fission tracks to model
simulate <- function(fit,N=100){
    b <- best(fit)
    m <- forward(b$P,b$M,b$S)
    dl <- m$l[2]-m$l[1]
    cdf <- cumsum(m$fc)*dl
    p <- seq(0,1,length.out=N+2)
    out <- approx(cdf,m$l,p)$y[2:(N-1)]
    out
}
