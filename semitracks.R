# fname: the name of a .csv file containing the length measurements
# confined = FALSE if fname contains semi-tracks, = TRUE if it contains confined tracks
# cutoff: the shortest semi track which we can reliably measure with the microscope
# header: does the .csv file contain a header?
# skip: how many lines does the header contain
read.data <- function(fname,confined=FALSE,cutoff=4,header=TRUE,skip=0){
    dat <- read.csv(file=fname,header=header,skip=skip)
    out <- list()
    out$confined <- confined
    out$l <- dat$True.Length
    out$a <- dat$Angle.to.C
    if (!confined) {
        islong <- out$l>cutoff
        out$l <- out$l[islong]
        out$a <- out$a[islong]
    }
    out
}

# P = vector with the proportions of the length peaks
# M = vector with the means of the length peaks
# S = vector with the standard deviations of the length peaks
# P, M and S must have the same lengths
forward <- function(P,M,S,mM=4,MM=16) {
    # calculate the confined and semi-track length distributions
    l <- seq(from=0,to=20,by=0.01) # confined fission track lengths to evaluate
    fc <- l
    fs <- l
    for (i in 1:length(l)){       # loop through all the lengths
        fc[i] <- getfcL(l[i],P,M,S)  # calculate the pdf of the confined track lengths
        fs[i] <- getfsL(l[i],P,M,S)  # calculate the pdf of the semi-track lengths
    }
    pms <- c(P2p(P),M2m(M,mM,MM),S2s(S))
    list(l=l,fs=fs,fc=fc,P=P,M=M,S=S,pms=pms)
}
forward.old <- function(P,M,S) {
    # calculate the confined and semi-track length distributions
    l <- seq(from=0,to=20,by=0.01) # confined fission track lengths to evaluate
    fc <- l
    fs <- l
    for (i in 1:length(l)){       # loop through all the lengths
        fc[i] <- getfcL.old(l[i],P,M,S)  # calculate the pdf of the confined track lengths
        fs[i] <- getfsL.old(l[i],P,M,S)  # calculate the pdf of the semi-track lengths
    }
    list(l=l,fs=fs,fc=fc,P=P,M=M,S=S)
}

# dat: fission track length data generated by the read.data function
# ncomp: the number of Normal components to fit
invert <- function(l,confined=FALSE,ncomp=3,mM=4,MM=16){
    pms <- rep(0,2*ncomp) # initialise with equal logratios
    if (confined) fit <- optim(pms,cmisfit,l=l)
    else fit <- optim(pms,smisfit,l=l,mM=mM,MM=MM)
    P <- p2P(fit$par[1:(ncomp-1)])
    M <- m2M(fit$par[ncomp:(2*ncomp-1)])
    S <- s2S(fit$par[2*ncomp])
    list(l=l,P=P,M=M,S=S)
}
invert.old <- function(l,confined=FALSE,ncomp=5){
    p <- rep(0,ncomp-1) # initialise with equal logratios
    M <- seq(4,16,length.out=ncomp+2)[2:(ncomp+1)] # equally spaced means
    S <- rep((M[2]-M[1])/2,ncomp) # constant standard deviations
    if (confined) fit <- optim(p,cmisfit.old,M=M,S=S,l=l)
    else fit <- optim(p,smisfit.old,M=M,S=S,l=l)
    P <- p2P(fit$par)
    list(l=l,P=P,M=M,S=S)
}

# maximum (negative) likelihood misfit function for confined tracks
cmisfit <- function(pms,l,mM=4,MM=16){
    ncomp <- length(pms)/2
    p <- pms[1:(ncomp-1)]
    P <- p2P(p)
    m <- pms[ncomp:(2*ncomp-1)]
    M <- m2M(m,mM,MM)
    s <- pms[2*ncomp]
    S <- s2S(s)
    fcL <- unlist(lapply(l,getfcL,P=P,M=M,S=S))
    -sum(log(fcL))
}
cmisfit.old <- function(p,M,S,l){
    P <- p2P(p)
    fcL <- unlist(lapply(l,getfcL.old,P=P,M=M,S=S))
    -sum(log(fcL))
}

# maximum (negative) likelihood misfit function for semi-tracks
smisfit <- function(pms,l,mM=4,MM=16){
    ncomp <- length(pms)/2
    p <- pms[1:(ncomp-1)]
    P <- p2P(p)
    m <- pms[ncomp:(2*ncomp-1)]
    M <- m2M(m,mM,MM)
    s <- pms[2*ncomp]
    S <- s2S(s)
    fsL <- unlist(lapply(l,getfsL,P=P,M=M,S=S))
    cutoff <- min(l)
    fsL.of.uncounted <- getfsL(cutoff,P=P,M=M,S=S)
    dl <- 2
    num.of.short.tracks <- sum(l>=cutoff & l<(cutoff+dl))
    num.uncounted <- num.of.short.tracks*cutoff/dl
    corr.term <- num.uncounted*log(fsL.of.uncounted)
    -(sum(log(fsL))+corr.term)
}
smisfit.old <- function(p,M,S,l){
    P <- p2P(p)
    fsL <- unlist(lapply(l,getfsL.old,P=P,M=M,S=S))
    cutoff <- min(l)
    fsL.of.uncounted <- getfsL.old(cutoff,P=P,M=M,S=S)
    dl <- 2
    num.of.short.tracks <- sum(l>=cutoff & l<(cutoff+dl))
    num.uncounted <- num.of.short.tracks*cutoff/dl
    corr.term <- num.uncounted*log(fsL.of.uncounted)
    -(sum(log(fsL))+corr.term)
}

# equation 7.53
getN <- function(mu){
    -5.18 + 1.42*mu - sqrt(11.48 - 2.13*mu + 0.1*mu^2)
}

# equation 7.53
getE <- function(mu){
    2*(mu-getN(mu))
}

# middle of page 140
getMs <- function(mu){
    getN(mu)+4*getE(mu)/(3*pi)
}

# equation 7.51
# get the probability density of length l and angle(s) phi
# M, S, l, theta and f are scalars
fcLPhi <- function(l,phi,M,S){
    N <- getN(M)
    E <- getE(M)
    dnorm(l,mean=N+E*cos(phi),sd=S)
}

# equation 2.4
# get the probability density at confined FT length l integrating over phi
# l is a scalar, while P, M and S are vectors of equal length
getfcL <- function(l,P,M,S){
    f <- 0
    for (i in 1:length(P)){
        integrand <- function(phi) {sin(phi)*fcLPhi(l,phi,M[i],S)}
        f <- f + P[i]*integrate(integrand,lower=0,upper=pi/2)$value
    }
    f
}
getfcL.old <- function(l,P,M,S){
    f <- 0
    for (i in 1:length(P)){
        integrand <- function(phi) {sin(phi)*fcLPhi(l,phi,M[i],S[i])}
        f <- f + P[i]*integrate(integrand,lower=0,upper=pi/2)$value
    }
    f
}

# first equation of page 126
# x, M and S are scalars, phi is a vector
FcLPhi <- function(x,phi,M,S){
    N <- getN(M)
    E <- getE(M)
    pnorm(x,mean=N+E*cos(phi),sd=S)
}

# equation 7.32
# probability density at semi-track length tt
getfsL <- function(tt,P,M,S){
    f <- 0 # initialise
    for (i in 1:length(P)){
        integrand <- function(phi) {(1-FcLPhi(tt,phi,M[i],S))*sin(phi)^2}
        Ms <- getMs(M[i])
        f <- f + P[i]*4*integrate(integrand,lower=0,upper=pi/2)$value/(pi*Ms)
    }
    f
}
getfsL.old <- function(tt,P,M,S){
    f <- 0 # initialise
    for (i in 1:length(P)){
        integrand <- function(phi) {(1-FcLPhi(tt,phi,M[i],S[i]))*sin(phi)^2}
        Ms <- getMs(M[i])
        f <- f + P[i]*4*integrate(integrand,lower=0,upper=pi/2)$value/(pi*Ms)
    }
    f
}

# m = forward model, d = data
plotModel <- function(m,d=NULL){
    xlab <- expression(paste("length [",mu,"m]"))
    if (is.null(d)){
        par(pty='s',mfrow=c(1,2))
        plot(m$l,m$fc,type='l',xlab=xlab,ylab='')
        title(main='confined tracks')
        plot(m$l,m$fs,type='l',xlab=xlab,ylab='')
        title(main='semi-tracks')
    } else {
        h <- hist(d$l)
        par(pty='s',mfrow=c(2,2))
        plot(d$l,d$a,type='p', xlab=xlab, ylab='angle to C')
        plot(h,freq=FALSE,main='',ylim=range(h$density,m$fs),xlab=xlab)
        if (d$confined){
            lines(m$l,m$fc)
            title(smisfit(m$pms,d$l))
            plot(m$l,m$fs,type='l',xlab=xlab)
        } else {
            cutoff <- min(d$l)
            fsL.of.uncounted <- getfsL(cutoff,P=m$P,M=m$M,S=m$S)
            corr.factor <- 1/(1-cutoff*fsL.of.uncounted)
            lines(m$l,m$fs*corr.factor)
            title(smisfit(m$pms,d$l))
            plot(m$l,m$fc,type='l',xlab=xlab,ylab='Density')
        }
    }
}
plotModel.old <- function(m,d=NULL){
    xlab <- expression(paste("length [",mu,"m]"))
    if (is.null(d)){
        par(pty='s',mfrow=c(1,2))
        plot(m$l,m$fc,type='l',xlab=xlab,ylab='')
        title(main='confined tracks')
        plot(m$l,m$fs,type='l',xlab=xlab,ylab='')
        title(main='semi-tracks')
    } else {
        h <- hist(d$l)
        par(pty='s',mfrow=c(2,2))
        plot(d$l,d$a,type='p', xlab=xlab, ylab='angle to C')
        plot(h,freq=FALSE,main='',ylim=range(h$density,m$fs),xlab=xlab)
        if (d$confined){
            lines(m$l,m$fc)
            title(smisfit.old(P2p(m$P),m$M,m$S,d$l))
            plot(m$l,m$fs,type='l',xlab=xlab)
        } else {
            cutoff <- min(d$l)
            fsL.of.uncounted <- getfsL.old(cutoff,P=m$P,M=m$M,S=m$S)
            corr.factor <- 1/(1-cutoff*fsL.of.uncounted)
            lines(m$l,m$fs*corr.factor)
            title(smisfit.old(P2p(m$P),m$M,m$S,d$l))
            plot(m$l,m$fc,type='l',xlab=xlab,ylab='Density')
        }
    }
}

# generates simulated confined fission tracks
# fit: the output of the inverse() function
# N: the number of confined fission tracks to model
simulate <- function(fit,N=100){
    b <- best(fit)
    m <- forward(b$P,b$M,b$S)
    dl <- m$l[2]-m$l[1]
    cdf <- cumsum(m$fc)*dl
    p <- seq(0,1,length.out=N+2)
    approx(cdf,m$l,p)$y[2:(N-1)]
}

# inverse logratio transformation
p2P <- function(p){
    c(exp(p),1)/(sum(exp(p))+1)
}

# inverse logratio transformation
# m = log of the ratios of the differences between the peak locations
# mM, MM = minimum and maximum track length
m2M <- function(m,mM=4,MM=16){
    nn <- length(m)
    dM <- c(exp(m),1)/(sum(exp(m))+1)
    mM + (MM-mM)*cumsum(dM)[1:nn]
}

s2S <- function(s){
    exp(s)
}

P2p <- function(P){
    nn <- length(P)
    log(P[1:(nn-1)])-log(P[nn])
}

M2m <- function(M,mM=4,MM=16){
    log(diff(c(mM,M,MM)))
}

S2s <- function(S){
    log(S)
}
